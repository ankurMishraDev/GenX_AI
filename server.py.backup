import asyncio
import json
import logging
import os
import base64
import websockets
import datetime as dt
from google import genai
from google.genai.types import LiveConnectConfig, PrebuiltVoiceConfig, SpeechConfig, VoiceConfig
from google.oauth2 import service_account
from google.auth.transport.requests import Request
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Import our new DB handler
import firebase_db

# Configuration
PROJECT_ID = "gen-ai-hack2skill-470416"
LOCATION = "us-central1"
MODEL = "gemini-live-2.5-flash-preview-native-audio"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load service account credentials
KEY_PATH = os.path.join(os.path.dirname(__file__), "service-account.json")
SCOPES = ["https://www.googleapis.com/auth/cloud-platform"]

def should_refresh_token(creds, buffer_seconds=300):
    """Check if token needs refresh (with 5-minute buffer)"""
    if not creds or not hasattr(creds, 'expiry') or not creds.expiry:
        return True
    if not creds.valid:
        return True
    time_until_expiry = (creds.expiry - dt.datetime.utcnow()).total_seconds()
    return time_until_expiry < buffer_seconds

class GenXServer:
    def __init__(self):
        # Initialize Vertex AI credentials
        self.creds = service_account.Credentials.from_service_account_file(
            KEY_PATH, scopes=SCOPES
        )
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = KEY_PATH
        
        # Initialize Vertex AI client
        self.client = genai.Client(
            vertexai=True,
            project=PROJECT_ID,
            location=LOCATION,
            credentials=self.creds
        )
        logger.info("âœ… Vertex AI client initialized")

    async def handle_client(self, websocket):
        logger.info("New client connected")
        uid = None
        
        try:
            # 1. Authentication Handshake
            auth_msg_raw = await websocket.recv()
            try:
                auth_msg = json.loads(auth_msg_raw)
            except json.JSONDecodeError:
                logger.error("Invalid JSON in auth message")
                await websocket.close(code=1008)
                return

            if auth_msg.get("type") != "auth":
                logger.error("First message was not auth")
                await websocket.close(code=1008)
                return

            token = auth_msg.get("token")
            uid = firebase_db.verify_token(token)
            
            if not uid:
                logger.error("Invalid Firebase Token")
                await websocket.close(code=1008)
                return
                
            logger.info(f"User authenticated: {uid}")
            
            # Send ready message to client
            await websocket.send(json.dumps({"type": "ready"}))
            logger.info("âœ… Sent ready message to client")
            
            # 2. Fetch Context & Prepare Session
            firebase_db.sync_user(uid)
            context = firebase_db.get_user_context(uid)
            
            # Build system instruction with user context
            user_profile = context.get('profile', {})
            current_plan = context.get('plan')
            
            system_instruction = f"""You are GenX, an advanced AI fitness and nutrition coach.

User Profile:
- Name: {user_profile.get('name', 'User')}
- Email: {user_profile.get('email', 'N/A')}

Current Active Plan: {json.dumps(current_plan, indent=2) if current_plan else 'No active plan yet'}

Your responsibilities:
1. Motivate and guide the user through their fitness journey
2. Answer questions about workouts, nutrition, and healthy lifestyle
3. When the user requests a new personalized plan, generate a comprehensive workout and nutrition plan
4. Use the create_plan tool to save the generated plan to the database

When generating plans, ensure they follow this structure:
- name: A descriptive name for the plan
- workoutPlan: Contains schedule (array of days) and exercises (array with day and routines)
- nutritionPlan: Contains caloriesIntake (number) and meals (array of meal objects with name and foods)

Be conversational, supportive, and professional."""

            # Define the create_plan tool for Gemini
            tools = [{
                "function_declarations": [{
                    "name": "create_plan",
                    "description": "Creates and saves a new fitness and nutrition plan for the user. This will deactivate any existing active plans.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "A descriptive name for the plan (e.g., 'Beginner Weight Loss Plan')"
                            },
                            "workoutPlan": {
                                "type": "object",
                                "properties": {
                                    "schedule": {
                                        "type": "array",
                                        "items": {"type": "string"},
                                        "description": "Array of days (e.g., ['Monday', 'Wednesday', 'Friday'])"
                                    },
                                    "exercises": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "day": {"type": "string"},
                                                "routines": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "name": {"type": "string"},
                                                            "sets": {"type": "number"},
                                                            "reps": {"type": "number"},
                                                            "duration": {"type": "number"},
                                                            "description": {"type": "string"}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "nutritionPlan": {
                                "type": "object",
                                "properties": {
                                    "caloriesIntake": {
                                        "type": "number",
                                        "description": "Target daily calorie intake"
                                    },
                                    "meals": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "name": {"type": "string"},
                                                "foods": {
                                                    "type": "array",
                                                    "items": {"type": "string"}
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "required": ["name", "workoutPlan", "nutritionPlan"]
                    }
                }]
            }]

            config = LiveConnectConfig(
                response_modalities=["AUDIO"],
                system_instruction=system_instruction,
                tools=tools,
                speech_config=SpeechConfig(
                    voice_config=VoiceConfig(
                        prebuilt_voice_config=PrebuiltVoiceConfig(voice_name="Puck")
                    )
                )
            )

            # 3. Refresh authentication token before session
            logger.info("â³ Refreshing authentication token...")
            try:
                if should_refresh_token(self.creds):
                    logger.info("Token needs refresh - refreshing now...")
                    self.creds.refresh(Request())
                    # Reinitialize client with fresh credentials
                    self.client = genai.Client(
                        vertexai=True,
                        project=PROJECT_ID,
                        location=LOCATION,
                        credentials=self.creds
                    )
                    logger.info("âœ… Token refreshed successfully")
                else:
                    logger.info("âœ… Token still valid")
            except Exception as auth_error:
                logger.error(f"âŒ Auth refresh failed: {auth_error}")
                await websocket.close(code=1011)
                return
            
            # 4. Start Gemini Session
            logger.info("â³ Connecting to Gemini Live API...")
            async with self.client.aio.live.connect(model=MODEL, config=config) as session:
                logger.info("âœ… Connected to Gemini Live")
                
                # Create audio queue for processing
                audio_queue = asyncio.Queue()
                
                # Task 1: Handle incoming WebSocket messages
                async def handle_websocket_messages():
                    try:
                        async for message in websocket:
                            data = json.loads(message)
                            
                            if data.get("type") == "audio":
                                # Decode base64 audio and put in queue
                                audio_bytes = base64.b64decode(data.get("data", ""))
                                await audio_queue.put(audio_bytes)
                            
                            elif data.get("type") == "end":
                                logger.info("ðŸ›‘ Received end signal from client")
                                # Could handle session end here if needed
                            
                            elif data.get("type") == "text":
                                text = data.get("data", "")
                                logger.info(f"ðŸ’¬ Received text: {text}")
                                await session.send_realtime_input(text=text)
                                
                    except websockets.exceptions.ConnectionClosed:
                        logger.info("ðŸ”Œ Client WebSocket closed")
                    except Exception as e:
                        logger.error(f"âŒ Error in handle_websocket_messages: {e}")
                        import traceback
                        traceback.print_exc()
                
                # Task 2: Process audio queue and send to Gemini
                async def process_and_send_audio():
                    try:
                        while True:
                            audio_data = await audio_queue.get()
                            await session.send_realtime_input(
                                media={
                                    "data": audio_data,
                                    "mime_type": "audio/pcm;rate=16000",
                                }
                            )
                            audio_queue.task_done()
                    except Exception as e:
                        logger.error(f"âŒ Error in process_and_send_audio: {e}")
                        import traceback
                        traceback.print_exc()
                
                # Task 3: Receive responses from Gemini and send to client
                async def receive_and_send_responses():
                    try:
                        async for response in session.receive():
                            # Handle server content
                            server_content = response.server_content
                            
                            # Check for interruption
                            if hasattr(server_content, "interrupted") and server_content.interrupted:
                                logger.info("ðŸ¤ Interruption detected")
                                try:
                                    await websocket.send(json.dumps({
                                        "type": "interrupted",
                                        "data": "Response interrupted"
                                    }))
                                except Exception:
                                    pass
                            
                            # Handle model turn (audio/text output)
                            if server_content and server_content.model_turn:
                                for part in server_content.model_turn.parts:
                                    # Send audio data
                                    if hasattr(part, 'inline_data') and part.inline_data:
                                        b64_audio = base64.b64encode(part.inline_data.data).decode('utf-8')
                                        await websocket.send(json.dumps({
                                            "type": "audio",
                                            "data": b64_audio
                                        }))
                                    
                                    # Log text output
                                    if hasattr(part, 'text') and part.text:
                                        logger.info(f"ðŸ’¬ Model text: {part.text}")
                                    
                                    # Handle function calls
                                    if hasattr(part, 'function_call') and part.function_call:
                                        function_name = part.function_call.name
                                        logger.info(f"âš™ï¸ Function call: {function_name}")
                                        
                                        if function_name == "create_plan":
                                            try:
                                                plan_args = part.function_call.args
                                                logger.info(f"Creating plan with args: {plan_args}")
                                                
                                                plan_id = firebase_db.create_plan(uid, plan_args)
                                                
                                                if plan_id:
                                                    logger.info(f"âœ… Plan created: {plan_id}")
                                                    await session.send(
                                                        function_response={
                                                            "name": "create_plan",
                                                            "response": {
                                                                "success": True,
                                                                "plan_id": plan_id,
                                                                "message": "Plan saved successfully"
                                                            }
                                                        }
                                                    )
                                                else:
                                                    logger.error("âŒ Failed to create plan")
                                                    await session.send(
                                                        function_response={
                                                            "name": "create_plan",
                                                            "response": {
                                                                "success": False,
                                                                "error": "Failed to save plan"
                                                            }
                                                        }
                                                    )
                                            except Exception as e:
                                                logger.error(f"Error in create_plan: {e}")
                                                await session.send(
                                                    function_response={
                                                        "name": "create_plan",
                                                        "response": {
                                                            "success": False,
                                                            "error": str(e)
                                                        }
                                                    }
                                                )
                            
                            # Handle turn complete
                            if server_content and server_content.turn_complete:
                                logger.info("âœ… Gemini turn complete")
                                try:
                                    await websocket.send(json.dumps({"type": "turn_complete"}))
                                except Exception:
                                    pass
                            
                            # Handle output transcription (what Gemini said)
                            output_transcription = getattr(server_content, "output_transcription", None)
                            if output_transcription and output_transcription.text:
                                text_out = output_transcription.text
                                logger.info(f"ðŸ“ Output transcription: {text_out}")
                                try:
                                    await websocket.send(json.dumps({
                                        "type": "text",
                                        "data": text_out
                                    }))
                                except Exception:
                                    pass
                            
                            # Handle input transcription (what user said)
                            input_transcription = getattr(server_content, "input_transcription", None)
                            if input_transcription and input_transcription.text:
                                text_in = input_transcription.text
                                logger.info(f"ðŸŽ™ï¸ Input transcription: {text_in}")
                                
                    except Exception as e:
                        logger.error(f"âŒ Error in receive_and_send_responses: {e}")
                        import traceback
                        traceback.print_exc()
                
                # Run all three tasks concurrently
                await asyncio.gather(
                    handle_websocket_messages(),
                    process_and_send_audio(),
                    receive_and_send_responses()
                )

        except Exception as e:
            logger.error(f"Session error: {e}")
        finally:
            logger.info(f"Session ended for {uid}")

    async def start(self):
        async with websockets.serve(self.handle_client, "localhost", 8000):
            logger.info("WebSocket server running on ws://localhost:8000")
            await asyncio.Future()  # Run forever

if __name__ == "__main__":
    server = GenXServer()
    try:
        asyncio.run(server.start())
    except KeyboardInterrupt:
        logger.info("Server stopped")
